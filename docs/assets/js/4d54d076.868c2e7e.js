"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[459],{3888:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>p,toc:()=>u});var a=n(8168),o=n(8587),i=(n(6540),n(5680));const r=["components"],s={id:"contributing",title:"Contributing"},l=void 0,p={unversionedId:"contributing",id:"contributing",title:"Contributing",description:"Lets work to make the Apollo experience in ReScript the best experience out there!",source:"@site/docs/contributing.md",sourceDirName:".",slug:"/contributing",permalink:"/rescript-apollo-client/docs/contributing",draft:!1,editUrl:"https://github.com/jeddeloh/rescript-apollo-client/edit/master/documentationWebsite/docs/contributing.md",tags:[],version:"current",frontMatter:{id:"contributing",title:"Contributing"}},d={},u=[{value:"Core Philosopies",id:"core-philosopies",level:2},{value:"Following a Consistent Pattern",id:"following-a-consistent-pattern",level:3},{value:"Avoiding Partial Types",id:"avoiding-partial-types",level:3},{value:"Style Guidelines",id:"style-guidelines",level:2},{value:"Directory Structure and Module Naming",id:"directory-structure-and-module-naming",level:3},{value:"Breaking it down: <code>/[1]/[2]__[3]_[4]</code>",id:"breaking-it-down-12__3_4",level:4},{value:"Types",id:"types",level:3},{value:"SubTypes",id:"subtypes",level:4},{value:"Binding to Js Module Exports",id:"binding-to-js-module-exports",level:3},{value:"Binding to Methods",id:"binding-to-methods",level:3},{value:"Binding to Objects",id:"binding-to-objects",level:3},{value:"Binding to Enums",id:"binding-to-enums",level:3},{value:"General",id:"general",level:3},{value:"Reasoning behind <code>Js_</code> modules",id:"reasoning-behind-js_-modules",level:3}],y={toc:u},m="wrapper";function c(e){let{components:t}=e,n=(0,o.A)(e,r);return(0,i.yg)(m,(0,a.A)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"Lets work to make the Apollo experience in ReScript the best experience out there!"),(0,i.yg)("h2",{id:"core-philosopies"},"Core Philosopies"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Provide 1:1 mapping to Javascript ",(0,i.yg)("em",{parentName:"li"},"then"),' use those as building blocks for more "reasonable" ergonomics'),(0,i.yg)("li",{parentName:"ul"},"Follow a consistent pattern for bindings"),(0,i.yg)("li",{parentName:"ul"},"Avoid partial types or bindings if possible"),(0,i.yg)("li",{parentName:"ul"},"Encourage incremental contribution from the community rather than biting off more than one person can chew")),(0,i.yg)("p",null,"There's nothing fancy about this library. It tends to view the problem of bindings as a people problem rather than a programming problem (all the hard work has already been done for us by Graphql-ppx) As such, a lot of detail is paid to consistency and clarity with the hope of maximizing human ability to both add and verify that bindings are correct. The long-term success or failure of this library is will likely be dependent on active community contribution rather than the efforts of a few individuals."),(0,i.yg)("h3",{id:"following-a-consistent-pattern"},"Following a Consistent Pattern"),(0,i.yg)("p",null,"At the file level, bindings to Javascript packages should mirror the directory structure in the JS package. This is critically important! It should be easy for anyone else to see exactly what is being bound and if anything is missing or incorrect. This has the side benefit of being able to navigate to any import you see in the javascript docs via filepath pattern, but it's primary purpose is consistency."),(0,i.yg)("p",null,"At the code level, all JS bindings should go in a ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_")," module of some sort. At first it seems ridiculous, but it pays off at scale. (See ",(0,i.yg)("strong",{parentName:"p"},"Reasoning Behind ",(0,i.yg)("inlineCode",{parentName:"strong"},"Js_")," modules"),")"),(0,i.yg)("h3",{id:"avoiding-partial-types"},"Avoiding Partial Types"),(0,i.yg)("p",null,"Please type something as completely as possible when you come across it or leave it for someone else (if nothing else, you can use an abstract type so things will still flow through everywhere and people can cast it when in a hurry). This way no one has to go back and duplicate that work of tracing through the same code you were just in ",(0,i.yg)("em",{parentName:"p"},"and")," we can trust that if a binding exists, it's probably complete and we can just reuse."),(0,i.yg)("h2",{id:"style-guidelines"},"Style Guidelines"),(0,i.yg)("h3",{id:"directory-structure-and-module-naming"},"Directory Structure and Module Naming"),(0,i.yg)("p",null,"Each directory should have a corresponding Reason module."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"@apollo/client/react/hooks/useQuery.js\n")),(0,i.yg)("p",null,"should become"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"src/react/hooks/ApolloClient__React_Hooks_UseQuery.res\n")),(0,i.yg)("h4",{id:"breaking-it-down-12__3_4"},"Breaking it down: ",(0,i.yg)("inlineCode",{parentName:"h4"},"/[1]/[2]__[3]_[4]")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"ReScript files should be located in the same directory structure as the js counterpart (usually there is a ",(0,i.yg)("inlineCode",{parentName:"li"},".d.ts")," for every ",(0,i.yg)("inlineCode",{parentName:"li"},".js")," file so we can think of them interchangeably)"),(0,i.yg)("li",{parentName:"ol"},"All module names should be prefixed with ",(0,i.yg)("inlineCode",{parentName:"li"},"ApolloClient__"),' "namespace"'),(0,i.yg)("li",{parentName:"ol"},"File names reflect the directory structure"),(0,i.yg)("li",{parentName:"ol"},"Files should be named the same as the js counterpart")),(0,i.yg)("h3",{id:"types"},"Types"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Please use the same naming as typescript where possible"),(0,i.yg)("li",{parentName:"ul"},"Every type goes in its own module with a ",(0,i.yg)("inlineCode",{parentName:"li"},"type t")," (exception: see SubStypes)"),(0,i.yg)("li",{parentName:"ul"},"Every type module should contain a ",(0,i.yg)("inlineCode",{parentName:"li"},"type t"),", a ",(0,i.yg)("inlineCode",{parentName:"li"},"Js_")," module with a ",(0,i.yg)("inlineCode",{parentName:"li"},"type t"),", and a ",(0,i.yg)("inlineCode",{parentName:"li"},"toJs")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"fromJs")," conversion function. ",(0,i.yg)("inlineCode",{parentName:"li"},"t => Js_.t")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"Js_.t => t")),(0,i.yg)("li",{parentName:"ul"},"Paste the type definition from the ",(0,i.yg)("inlineCode",{parentName:"li"},".d.ts")," file above the ",(0,i.yg)("inlineCode",{parentName:"li"},"type t")," in the ",(0,i.yg)("inlineCode",{parentName:"li"},"Js_")," module"),(0,i.yg)("li",{parentName:"ul"},"If data requires parsing/serializing create a new record even if the shape is the same. This ensures you don't forget to parse somewhere."),(0,i.yg)("li",{parentName:"ul"},"Prefer single types when the more complicated type in a union can express both ",(0,i.yg)("inlineCode",{parentName:"li"},"shouldResubscribe?: boolean | ((options: BaseSubscriptionOptions<TData, TVariables>) => boolean);")),(0,i.yg)("li",{parentName:"ul"},"Do all of this even if it doesn't need it (See Reasoning Behind ",(0,i.yg)("inlineCode",{parentName:"li"},"Js_")," modules)")),(0,i.yg)("p",null,"Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"// #1 - create a Js_ module for your type\nmodule Js_ = {\n  // #2 - paste the definition from the .js file here\n  // #3 - add the `.js` representation of type t = ...\n}\n\n// #4  - add the ReScript representation of type t\n// #4a - you can use `type t = Js_.t` if they are _exactly_ the same\n// #4b - if they are the exact same _shape_ but requires parsing or serializing, *define a new record of the same shape* so we can leverage the fact that records are nominally typed to prevent someone forgetting to convert somewhere\n\n// #5 - add `toJs` or `fromJs`. They often require parsing: `let fromJs: Js_.t('jsData, ~parse: 'jsData => 'data) => t('data)`\n")),(0,i.yg)("h4",{id:"subtypes"},"SubTypes"),(0,i.yg)("p",null,"Sometimes multiple types were required to represent a single type in TypeScript. In order to help make it clear what is a binding to an actual type and what is just needed by ReScript, we take a similar naming approach to the modules (prefixing with the parent). For instance, ",(0,i.yg)("inlineCode",{parentName:"p"},"Apollo_Client__React_Types.QueryResult.Raw")," has a ",(0,i.yg)("inlineCode",{parentName:"p"},"type t")," that uses ",(0,i.yg)("inlineCode",{parentName:"p"},"t_fetchMoreOptions")," which in turn uses ",(0,i.yg)("inlineCode",{parentName:"p"},"t_fetchMoreOptions_updateQueryOptions"),"."),(0,i.yg)("h3",{id:"binding-to-js-module-exports"},"Binding to Js Module Exports"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"externals")," go under a ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_")," module and any types they reference should be ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_.t")," versions."),(0,i.yg)("h3",{id:"binding-to-methods"},"Binding to Methods"),(0,i.yg)("p",null,"Prefer T-first with ",(0,i.yg)("inlineCode",{parentName:"p"},"[@send]"),". Again, ",(0,i.yg)("inlineCode",{parentName:"p"},"externals")," go under a ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_")," module with a ",(0,i.yg)("inlineCode",{parentName:"p"},"type t")," and any types they reference should be ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_.t")," versions."),(0,i.yg)("h3",{id:"binding-to-objects"},"Binding to Objects"),(0,i.yg)("p",null,"Use records"),(0,i.yg)("h3",{id:"binding-to-enums"},"Binding to Enums"),(0,i.yg)("p",null,"Prefer standard variants. ",(0,i.yg)("inlineCode",{parentName:"p"},"jsConverter")," works great for ints, but otherwise use manual ",(0,i.yg)("inlineCode",{parentName:"p"},"toJs")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"fromJs")," functions. Standard variants are just nicer to consume in other places and this keeps consistency"),(0,i.yg)("h3",{id:"general"},"General"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Prefer T-first because that's the Reason community default"),(0,i.yg)("li",{parentName:"ul"},"Hooks are T-last because that makes sense given their usage"),(0,i.yg)("li",{parentName:"ul"},"ApolloClient methods are a Frankenstein T-first ",(0,i.yg)("em",{parentName:"li"},"and")," T-last because they want to maintain similarity with hooks api, but are also T-first due to ","[@send]"," and T-first preference")),(0,i.yg)("h3",{id:"reasoning-behind-js_-modules"},"Reasoning behind ",(0,i.yg)("inlineCode",{parentName:"h3"},"Js_")," modules"),(0,i.yg)("p",null,"Here's a typical example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"module TypeName = {\n  module Js_ = {\n    type t;\n  }\n\n  type t = Js_.t;\n};\n")),(0,i.yg)("p",null,"Not much point yet, but bear with me, it pays off in the big picture. What if we need to parse/serialize some data which happens a lot in this library?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-diff"},"module TypeName = {\n  module Js_ = {\n-   type t;\n+   type t('jsData) = {\n+     data: 'jsData,\n+   };\n  }\n\n- type t = Js_.t;\n+ type t('data) = {\n+   data: 'data\n+ };\n\n+ let toJs: t => Js_.t = (t, ~serialize) => {\n+   data: serialize(t.data)\n+ };\n};\n")),(0,i.yg)("p",null,"Nice, now when wherever we say we want a ",(0,i.yg)("inlineCode",{parentName:"p"},"Typename.t"),", we can never forget to parse because records are nominally typed."),(0,i.yg)("p",null,"What if you need to construct a class or object with a bunch of optional properties?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-diff"},"module TypeName = {\n  module Js_ = {\n    type t('jsData) = {\n      data: 'jsData,\n+     optionalProp: option(bool),\n    };\n\n+   type make_options('jsData) = {\n+     data: 'jsData,\n+     optionalProp: option(bool),\n+   }\n\n+   [@new] [@module \"someModule\"]\n+   external make = (make_options('jsData)) => t = \"someClass\";\n  }\n\n  type t('data) = {\n    data: 'data,\n+   optionalProp: option(bool),\n  };\n\n  let toJs: t => Js_.t = (t) => {\n    data: serialize(t.data)\n+   optionalProp: t.optionalProp\n  };\n\n+ let make: (~data, ~optionalProp=?, ()) =>\n+   Js_.make(\n+     toJs({\n+         data,\n+         optionalProp\n+       },\n+       ~serialize,\n+     )\n+   );\n};\n")),(0,i.yg)("p",null,"It's nice to have all this conversion stuff wrapped in one module and have consistent naming. All of it together really begins to pay off when we have types that reference many other types."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-diff"},"module TypeName = {\n  module Js_ = {\n    type t('jsData) = {\n      data: 'jsData,\n+     reusedType: ReusedType.Js_.t\n    };\n\n    type make_options('jsData) = {\n      data: 'jsData,\n      optionalProp: option(bool),\n+     reusedType: ReusedType.Js_.t\n    }\n    [@new] [@module \"someModule\"]\n    external make = (make_options('jsData)) => t = \"someClass\";\n  }\n\n  type t('data) = {\n    data: 'data,\n    optionalProp: option(bool),\n+   reusedType: ReusedType.t\n  };\n\n- let toJs: t => Js_.t = (t) => {\n+ let toJs: t => Js_.t = (t, ~serialize) => {\n    data: serialize(t.data)\n    optionalProp: t.optionalProp\n+   reusedType: t.reusedType->ReusedType.toJs(~serialize)\n  };\n\n- let make: (~data, ~optionalProp=?, ()) =>\n+ let make: (~data, ~optionalProp=?, ~reusedType, ~serialize, ()) =>\n    Js_.make(\n      toJs({\n          data,\n          optionalProp\n+         reusedType\n        },\n        ~serialize,\n      )\n    );\n};\n")),(0,i.yg)("p",null,"Does ",(0,i.yg)("inlineCode",{parentName:"p"},"reusedType")," need some conversion or parsing or serializing? If we've done things right, all we need to confirm is that any ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_")," modules reference the ",(0,i.yg)("inlineCode",{parentName:"p"},"Js_.t")," versions of types, the compiler will do the rest! In this case, it turns out it needs also needs parse!"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-diff"},"module TypeName = {\n  module Js_ = {\n    type t('jsData) = {\n      data: 'jsData,\n      reusedType: ReusedType.Js_.t\n    };\n\n    type make_options('jsData) = {\n      data: 'jsData,\n      optionalProp: option(bool),\n      reusedType: ReusedType.Js_.t\n    }\n    [@new] [@module \"someModule\"]\n    external make = (make_options('jsData)) => t = \"someClass\";\n  }\n\n  type t('data) = {\n    data: 'data,\n    optionalProp: option(bool),\n    reusedType: ReusedType.t\n  };\n\n- let toJs: t => Js_.t = (t, ~serialize) => {\n+ let toJs: t => Js_.t = (t, ~parse, ~serialize) => {\n    data: serialize(t.data)\n    optionalProp: t.optionalProp\n-   reusedType: t.reusedType->ReusedType.toJs(~serialize)\n+   reusedType: t.reusedType->ReusedType.toJs(~parse, ~serialize)\n  };\n\n- let make: (~data, ~optionalProp=?, ~reusedType, ~serialize, ()) =>\n+ let make: (~data, ~optionalProp=?, ~parse, ~reusedType, ~serialize, ()) =>\n    Js_.make(\n      toJs({\n          data,\n          optionalProp\n          reusedType\n        },\n        ~serialize,\n      )\n    );\n};\n")))}c.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>c});var a=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,c=u["".concat(l,".").concat(m)]||u[m]||y[m]||i;return n?a.createElement(c,r(r({ref:t},d),{},{components:n})):a.createElement(c,r({ref:t},d))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);